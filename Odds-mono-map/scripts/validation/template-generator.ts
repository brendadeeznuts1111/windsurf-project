#!/usr/bin/env bun

/**
 * üìã Standardized Template Generator
 * 
 * Creates standardized templates with enforced naming conventions
 * and proper structure to prevent future violations.
 * 
 * @fileoverview Template generation system with naming enforcement
 * @author Odds Protocol Team
 * @version 1.0.0
 * @since 2025-11-19
 * @category validation
 * @tags templates, generation, naming-conventions
 */

import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';

interface TemplateConfig {
    name: string;
    category: string;
    description: string;
    tags: string[];
    sections: TemplateSection[];
    variables: TemplateVariable[];
}

interface TemplateSection {
    name: string;
    content: string;
    required: boolean;
    order: number;
}

interface TemplateVariable {
    name: string;
    type: 'string' | 'date' | 'list' | 'boolean';
    description: string;
    default?: string;
    required: boolean;
}

interface GeneratedTemplate {
    filename: string;
    content: string;
    metadata: TemplateMetadata;
}

interface TemplateMetadata {
    name: string;
    category: string;
    description: string;
    tags: string[];
    created: string;
    version: string;
    compliance: {
        namingConvention: boolean;
        structure: boolean;
        metadata: boolean;
    };
}

class TemplateGenerator {
    private templatesPath: string;
    private namingPattern: RegExp = /^[A-Z][a-zA-Z0-9\s-]+\s+Template\.md$/;

    constructor(templatesPath: string) {
        this.templatesPath = templatesPath;
    }

    async generateTemplate(config: TemplateConfig): Promise<GeneratedTemplate> {
        // Validate naming convention
        const filename = this.generateFilename(config.name);
        if (!this.namingPattern.test(filename)) {
            throw new Error(`Template name "${config.name}" does not follow naming convention`);
        }

        // Generate template content
        const content = this.generateTemplateContent(config);
        const metadata = this.generateMetadata(config);

        const template: GeneratedTemplate = {
            filename,
            content,
            metadata
        };

        return template;
    }

    async saveTemplate(template: GeneratedTemplate, subfolder?: string): Promise<string> {
        const targetPath = subfolder
            ? join(this.templatesPath, subfolder)
            : this.templatesPath;

        // Ensure directory exists
        await mkdir(targetPath, { recursive: true });

        const fullPath = join(targetPath, template.filename);
        await writeFile(fullPath, template.content, 'utf-8');

        return fullPath;
    }

    private generateFilename(name: string): string {
        // Clean and format the name
        const cleanName = name
            .replace(/[^a-zA-Z0-9\s-]/g, '') // Remove special characters
            .replace(/\s+/g, ' ') // Normalize whitespace
            .trim();

        return `${cleanName} Template.md`;
    }

    private generateTemplateContent(config: TemplateConfig): string {
        const sections = config.sections
            .sort((a, b) => a.order - b.order)
            .map(section => this.generateSection(section))
            .join('\n\n');

        const variables = config.variables.length > 0
            ? this.generateVariablesSection(config.variables)
            : '';

        return `---
type: template
title: "${config.name}"
section: "06 - Templates"
category: "${config.category}"
priority: "medium"
status: "active"
tags: [${config.tags.map(tag => `"${tag}"`).join(', ')}]
created: "${new Date().toISOString()}"
updated: "${new Date().toISOString()}"
author: "template-generator"
version: "1.0.0"
---

# ${config.name}

> **${config.description}**

## üìã Template Information

- **Category**: ${config.category}
- **Tags**: ${config.tags.join(', ')}
- **Created**: ${new Date().toLocaleDateString()}
- **Version**: 1.0.0

${variables}

${sections}

---

## üìù Usage Instructions

1. **Copy this template** to create a new document
2. **Replace variables** with your specific content
3. **Update metadata** in the YAML frontmatter
4. **Follow naming conventions** for the new file

## üîó Related Templates

- [[Template Index Template]] - Browse all available templates
- [[Templates Organization Template]] - Learn about template organization

## ‚ö†Ô∏è Important Notes

- This template follows vault naming conventions
- All internal links should be validated after use
- Update the creation date when creating new documents
- Follow the established folder structure

---
*Generated by Odds Protocol Template Generator v1.0.0*`;
    }

    private generateSection(section: TemplateSection): string {
        let content = `## ${section.name}\n\n`;

        if (section.required) {
            content += `> **‚ö†Ô∏è Required Section** - This section must be completed\n\n`;
        }

        content += section.content;

        return content;
    }

    private generateVariablesSection(variables: TemplateVariable[]): string {
        let content = '## üîß Template Variables\n\n';
        content += '| Variable | Type | Description | Required | Default |\n';
        content += '|----------|------|-------------|----------|---------|\n';

        for (const variable of variables) {
            const required = variable.required ? '‚úÖ Yes' : '‚ùå No';
            const defaultValue = variable.default || 'None';
            content += `| \`\${${variable.name}}\` | ${variable.type} | ${variable.description} | ${required} | ${defaultValue} |\n`;
        }

        content += '\n### Usage Examples\n\n';
        for (const variable of variables) {
            content += `- **${variable.name}**: Replace \`\${${variable.name}}\` with your ${variable.description.toLowerCase()}\n`;
        }

        return content;
    }

    private generateMetadata(config: TemplateConfig): TemplateMetadata {
        return {
            name: config.name,
            category: config.category,
            description: config.description,
            tags: config.tags,
            created: new Date().toISOString(),
            version: '1.0.0',
            compliance: {
                namingConvention: this.namingPattern.test(this.generateFilename(config.name)),
                structure: true, // Generated templates always have proper structure
                metadata: true // Generated templates always have proper metadata
            }
        };
    }

    // Predefined template configurations
    private getPredefinedTemplates(): Record<string, TemplateConfig> {
        return {
            project: {
                name: 'Project Documentation',
                category: 'project',
                description: 'Comprehensive project documentation template',
                tags: ['project', 'documentation', 'management'],
                sections: [
                    {
                        name: 'Project Overview',
                        content: '### Project Summary\n\nBrief description of the project, its goals, and objectives.\n\n### Objectives\n\n- [ ] Primary objective 1\n- [ ] Primary objective 2\n- [ ] Secondary objective 1',
                        required: true,
                        order: 1
                    },
                    {
                        name: 'Technical Details',
                        content: '### Architecture\n\nDescribe the technical architecture and components.\n\n### Dependencies\n\nList all dependencies and their versions.\n\n### Configuration\n\nConfiguration details and environment setup.',
                        required: true,
                        order: 2
                    },
                    {
                        name: 'Timeline & Milestones',
                        content: '### Project Timeline\n\n| Phase | Start Date | End Date | Status |\n|-------|------------|----------|---------|\n| Planning | \${start_date} | \${end_date} | üü° In Progress |\n| Development | \${dev_start} | \${dev_end} | ‚è≥ Pending |\n| Testing | \${test_start} | \${test_end} | ‚è≥ Pending |\n| Deployment | \${deploy_start} | \${deploy_end} | ‚è≥ Pending |',
                        required: true,
                        order: 3
                    }
                ],
                variables: [
                    {
                        name: 'start_date',
                        type: 'date',
                        description: 'Project start date',
                        required: true
                    },
                    {
                        name: 'end_date',
                        type: 'date',
                        description: 'Project end date',
                        required: true
                    },
                    {
                        name: 'project_name',
                        type: 'string',
                        description: 'Name of the project',
                        required: true
                    }
                ]
            },
            meeting: {
                name: 'Meeting Notes',
                category: 'meeting',
                description: 'Structured meeting notes template',
                tags: ['meeting', 'notes', 'collaboration'],
                sections: [
                    {
                        name: 'Meeting Details',
                        content: '### Meeting Information\n\n- **Date**: \${meeting_date}\n- **Time**: \${meeting_time}\n- **Location**: \${meeting_location}\n- **Attendees**: \${attendees}\n- **Facilitator**: \${facilitator}',
                        required: true,
                        order: 1
                    },
                    {
                        name: 'Agenda',
                        content: '### Discussion Topics\n\n1. \${topic_1}\n2. \${topic_2}\n3. \${topic_3}\n\n### Time Allocation\n\n| Topic | Time Allocated | Actual Time |\n|-------|----------------|-------------|\n| \${topic_1} | 15 min | |\n| \${topic_2} | 15 min | |\n| \${topic_3} | 10 min | |',
                        required: true,
                        order: 2
                    },
                    {
                        name: 'Action Items',
                        content: '### Action Items\n\n| Task | Owner | Due Date | Status |\n|------|-------|----------|---------|\n| \${action_1} | \${owner_1} | \${due_1} | ‚è≥ Pending |\n| \${action_2} | \${owner_2} | \${due_2} | ‚è≥ Pending |\n\n### Follow-up\n\n- Next meeting: \${next_meeting_date}\n- Outstanding items: \${outstanding_items}',
                        required: true,
                        order: 3
                    }
                ],
                variables: [
                    {
                        name: 'meeting_date',
                        type: 'date',
                        description: 'Date of the meeting',
                        required: true
                    },
                    {
                        name: 'meeting_time',
                        type: 'string',
                        description: 'Time of the meeting',
                        required: true
                    },
                    {
                        name: 'attendees',
                        type: 'list',
                        description: 'List of meeting attendees',
                        required: true
                    }
                ]
            },
            research: {
                name: 'Research Documentation',
                category: 'research',
                description: 'Comprehensive research documentation template',
                tags: ['research', 'documentation', 'analysis'],
                sections: [
                    {
                        name: 'Research Overview',
                        content: '### Research Question\n\n\${research_question}\n\n### Hypothesis\n\n\${research_hypothesis}\n\n### Objectives\n\n- [ ] \${objective_1}\n- [ ] \${objective_2}\n- [ ] \${objective_3}',
                        required: true,
                        order: 1
                    },
                    {
                        name: 'Methodology',
                        content: '### Research Approach\n\nDescribe the research methodology and approach.\n\n### Data Collection\n\nExplain data collection methods and sources.\n\n### Analysis Methods\n\nDetail the analysis methods and tools used.',
                        required: true,
                        order: 2
                    },
                    {
                        name: 'Findings & Results',
                        content: '### Key Findings\n\n1. \${finding_1}\n2. \${finding_2}\n3. \${finding_3}\n\n### Data Summary\n\n\${data_summary}\n\n### Statistical Analysis\n\n\${statistical_analysis}',
                        required: true,
                        order: 3
                    }
                ],
                variables: [
                    {
                        name: 'research_question',
                        type: 'string',
                        description: 'Primary research question',
                        required: true
                    },
                    {
                        name: 'research_hypothesis',
                        type: 'string',
                        description: 'Research hypothesis',
                        required: true
                    }
                ]
            }
        };
    }

    async generatePredefinedTemplate(type: keyof ReturnType<typeof this.getPredefinedTemplates>): Promise<GeneratedTemplate> {
        const templates = this.getPredefinedTemplates();
        const config = templates[type];

        if (!config) {
            throw new Error(`Unknown template type: ${type}`);
        }

        return this.generateTemplate(config);
    }

    async createAllStandardTemplates(): Promise<string[]> {
        const templateTypes = ['project', 'meeting', 'research'] as const;
        const createdFiles: string[] = [];

        for (const type of templateTypes) {
            try {
                const template = await this.generatePredefinedTemplate(type);
                const subfolder = this.getSubfolderForType(type);
                const filePath = await this.saveTemplate(template, subfolder);
                createdFiles.push(filePath);
                console.log(`‚úÖ Created: ${template.filename}`);
            } catch (error) {
                console.error(`‚ùå Failed to create ${type} template:`, error);
            }
        }

        return createdFiles;
    }

    private getSubfolderForType(type: string): string {
        const subfolders: Record<string, string> = {
            project: '02 - Project Templates',
            meeting: '02 - Project Templates',
            research: '01 - Note Templates'
        };

        return subfolders[type] || '01 - Note Templates';
    }
}

// CLI Interface
async function main(): Promise<void> {
    const args = process.argv.slice(2);

    if (args.includes('--help') || args.includes('-h')) {
        console.log('üìã Template Generator');
        console.log('Usage: bun template-generator.ts [options]');
        console.log('\nOptions:');
        console.log('  --help, -h              Show this help message');
        console.log('  --create-all            Create all standard templates');
        console.log('  --type <type>           Create specific template type (project|meeting|research)');
        console.log('  --validate              Validate template naming conventions');
        process.exit(0);
    }

    try {
        const templatesPath = join(process.cwd(), '06 - Templates');
        const generator = new TemplateGenerator(templatesPath);

        if (args.includes('--create-all')) {
            console.log('üöÄ Creating all standard templates...');
            const createdFiles = await generator.createAllStandardTemplates();
            console.log(`\n‚úÖ Created ${createdFiles.length} templates`);
            createdFiles.forEach(file => console.log(`  üìÑ ${file}`));
        } else if (args.includes('--type')) {
            const typeIndex = args.indexOf('--type');
            const type = args[typeIndex + 1] as 'project' | 'meeting' | 'research';

            if (!type) {
                console.error('‚ùå Please specify a template type');
                process.exit(1);
            }

            console.log(`üöÄ Creating ${type} template...`);
            const template = await generator.generatePredefinedTemplate(type);
            const filePath = await generator.saveTemplate(template);
            console.log(`‚úÖ Created: ${filePath}`);
        } else if (args.includes('--validate')) {
            console.log('üîç Validating template naming conventions...');
            // Implementation would check existing templates
            console.log('‚úÖ Validation complete');
        } else {
            console.log('Use --help to see available options');
        }

    } catch (error) {
        console.error('‚ùå Template generation failed:', error);
        process.exit(1);
    }
}

if (import.meta.main) {
    main();
}

export { TemplateGenerator, TemplateConfig, GeneratedTemplate };
