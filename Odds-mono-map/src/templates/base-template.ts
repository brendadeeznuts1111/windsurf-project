/**
 * Base Template System for Odds Protocol Vault
 * Consolidates duplicate templates into inheritance hierarchy
 * 
 * @fileoverview Template base classes and inheritance system
 * @author Odds Protocol Team
 * @version 1.0.0
 * @since 2025-11-18
 */

import {
    BaseTemplate,
    TemplateContext,
    TemplateResult,
    ProjectTemplate,
    NoteTemplate,
    ProjectPhase,
    NoteSection,
    TaskTemplate,
    TemplateConfig,
    ProjectTemplateConfig,
    NoteTemplateConfig
} from './template-types.js';
import { logger } from '../core/error-handler.js';

// ============================================================================
// ABSTRACT BASE TEMPLATE CLASS
// ============================================================================

export abstract class AbstractBaseTemplate implements BaseTemplate {
    public readonly name: string;
    public readonly description: string;
    public readonly version: string;
    public readonly author: string;
    public readonly category: string;
    public readonly tags: string[];

    constructor(config: TemplateConfig) {
        this.name = config.name;
        this.description = config.description;
        this.version = config.version;
        this.author = config.author;
        this.category = config.category;
        this.tags = config.tags || [];
    }

    abstract render(context: TemplateContext): TemplateResult;

    validate(context: TemplateContext): boolean {
        try {
            // Basic validation
            if (!context.file) {
                logger.logError('Template validation failed: missing file context');
                return false;
            }

            if (!context.vault) {
                logger.logError('Template validation failed: missing vault context');
                return false;
            }

            // Category-specific validation
            return this.validateCategory(context);
        } catch (error) {
            logger.logError(`Template validation error in ${this.name}`, { error, context });
            return false;
        }
    }

    protected validateCategory(context: TemplateContext): boolean {
        // Override in subclasses for category-specific validation
        return true;
    }

    protected createResult(content: string, metadata: Record<string, any> = {}): TemplateResult {
        return {
            content,
            metadata: {
                template: this.name,
                version: this.version,
                category: this.category,
                generatedAt: new Date().toISOString(),
                ...metadata
            },
            success: true,
            errors: []
        };
    }

    protected createError(message: string, errors: string[] = []): TemplateResult {
        return {
            content: '',
            metadata: {
                template: this.name,
                version: this.version,
                category: this.category,
                generatedAt: new Date().toISOString()
            },
            success: false,
            errors: [message, ...errors]
        };
    }

    protected generateHeader(context: TemplateContext, title?: string): string {
        const pageTitle = title || context.file.name.replace(/\.[^/.]+$/, '');
        return `---
type: ${this.category}
title: ${pageTitle}
section: "${this.getSectionNumber()}"
category: "${this.category}"
priority: "high"
status: "active"
tags: ${JSON.stringify(this.tags)}
created: ${context.date.now.toISOString()}
updated: ${context.date.now.toISOString()}
author: ${context.user.name}
review-cycle: 30
version: "${this.version}"
---

`;
    }

    protected getSectionNumber(): string {
        // Map categories to section numbers
        const sectionMap: Record<string, string> = {
            'project': '02',
            'note': '01',
            'documentation': '04',
            'development': '03',
            'template': '06'
        };
        return sectionMap[this.category] || '01';
    }

    protected generateFooter(): string {
        return `

---

## üìû **Quick Actions**

### ‚ö° **Next Steps**
- [ ] Review and customize content
- [ ] Add specific details and requirements
- [ ] Set up dependencies and timelines
- [ ] Configure notifications and reminders

### üîó **Related Resources**
- [[üìã Template Index - Quick Navigation]]
- [[üìö Template Library - Master Collection]]
- [[üîß Enhanced Standards Implementation]]

---
**${this.category.charAt(0).toUpperCase() + this.category.slice(1)} Template** ‚Ä¢ **Version ${this.version}** ‚Ä¢ **Generated by Odds Protocol**
`;
    }
}

// ============================================================================
// PROJECT TEMPLATE BASE CLASS
// ============================================================================

export abstract class AbstractProjectTemplate extends AbstractBaseTemplate implements ProjectTemplate {
    public readonly category: 'project' = 'project';
    public readonly projectType: 'software' | 'research' | 'documentation' | 'design';
    public readonly phases: ProjectPhase[];

    constructor(config: ProjectTemplateConfig) {
        super(config);
        this.projectType = config.projectType;
        this.phases = config.phases || [];
    }

    protected validateCategory(context: TemplateContext): boolean {
        // Project-specific validation
        if (!context.file.frontmatter?.projectType) {
            logger.logWarning('Project template missing project type in frontmatter');
        }
        return true;
    }

    protected generateProjectStructure(context: TemplateContext): string {
        const phases = this.phases.map(phase => this.generatePhaseSection(phase)).join('\n\n');
        return `## üéØ **Project Overview**

### **üìã Project Details**
- **Type**: ${this.projectType}
- **Status**: Planning
- **Priority**: High
- **Created**: ${context.date.today}
- **Team**: ${context.user.name}

### **üéØ Objectives**
- Define clear project goals and success criteria
- Establish timeline and milestones
- Allocate resources and responsibilities

---

## üìÖ **Project Phases**

${phases}

---

## üìä **Project Metrics**

### **üìà Progress Tracking**
- **Overall Progress**: 0%
- **Current Phase**: Planning
- **Tasks Completed**: 0/0
- **Budget Utilized**: 0%

### **‚è∞ Timeline**
- **Start Date**: ${context.date.today}
- **Estimated Completion**: TBD
- **Duration**: TBD
- **Buffer Time**: 20%

---

## üë• **Team & Responsibilities**

### **üé≠ Roles**
- **Project Lead**: ${context.user.name}
- **Developers**: TBD
- **Designers**: TBD
- **QA/Testers**: TBD

### **üìã Communication**
- **Daily Standups**: 9:00 AM
- **Weekly Reviews**: Friday 4:00 PM
- **Sprint Planning**: Bi-weekly
- **Retrospectives**: End of sprint

---

## üîß **Resources & Dependencies**

### **üõ†Ô∏è Tools & Technologies**
- **Development Environment**: TBD
- **Version Control**: Git
- **Project Management**: Tasks Plugin
- **Documentation**: Obsidian Vault

### **üîó External Dependencies**
- **APIs**: TBD
- **Services**: TBD
- **Libraries**: TBD
- **Hardware**: TBD

---

## üö® **Risks & Mitigation**

### **‚ö†Ô∏è Identified Risks**
- **Technical**: TBD
- **Resource**: TBD
- **Timeline**: TBD
- **Scope**: TBD

### **üõ°Ô∏è Mitigation Strategies**
- **Technical**: Code reviews, testing
- **Resource**: Cross-training, documentation
- **Timeline**: Buffer time, agile methodology
- **Scope**: Clear requirements, change control

---

## üìù **Documentation & Deliverables**

### **üìö Required Documentation**
- [ ] Technical Specifications
- [ ] User Documentation
- [ ] API Documentation
- [ ] Deployment Guide

### **üéØ Key Deliverables**
- [ ] Minimum Viable Product (MVP)
- [ ] Beta Release
- [ ] Production Release
- [ ] Maintenance Documentation

---

## üìä **Success Criteria**

### **üéØ Technical Goals**
- [ ] All core features implemented
- [ ] Performance benchmarks met
- [ ] Security requirements satisfied
- [ ] Scalability targets achieved

### **üìà Business Goals**
- [ ] User adoption targets met
- [ ] ROI goals achieved
- [ ] Market penetration successful
- [ ] Customer satisfaction high

---

## üîÑ **Next Steps**

### **‚ö° Immediate Actions (This Week)**
1. [ ] Finalize project requirements
2. [ ] Set up development environment
3. [ ] Create detailed project plan
4. [ ] Assemble core team

### **üìÖ Short-term Goals (Next 2 Weeks)**
1. [ ] Complete technical architecture
2. [ ] Set up CI/CD pipeline
3. [ ] Begin core development
4. [ ] Establish testing framework

### **üöÄ Long-term Goals (Next Month)**
1. [ ] Complete MVP development
2. [ ] Begin beta testing
3. [ ] Prepare for production launch
4. [ ] Plan post-launch maintenance

---

${this.generateFooter()}`;
    }

    private generatePhaseSection(phase: ProjectPhase): string {
        const tasks = phase.tasks.map(task =>
            `- [ ] ${task.title} (${task.estimatedHours}h) - ${task.description}`
        ).join('\n    ');

        return `### **${phase.name}** - ${phase.status}

**Description**: ${phase.description}

**Tasks**:
    ${tasks}

**Dependencies**: ${phase.tasks.map(t => t.dependencies.join(', ')).filter(Boolean).join(', ') || 'None'}

**Estimated Time**: ${phase.tasks.reduce((sum, task) => sum + task.estimatedHours, 0)} hours`;
    }
}

// ============================================================================
// NOTE TEMPLATE BASE CLASS
// ============================================================================

export abstract class AbstractNoteTemplate extends AbstractBaseTemplate implements NoteTemplate {
    public readonly category: 'note' = 'note';
    public readonly noteType: 'daily' | 'meeting' | 'research' | 'guide' | 'documentation';
    public readonly sections: NoteSection[];

    constructor(config: NoteTemplateConfig) {
        super(config);
        this.noteType = config.noteType;
        this.sections = config.sections || [];
    }

    protected validateCategory(context: TemplateContext): boolean {
        // Note-specific validation
        if (!context.file.frontmatter?.type) {
            logger.logWarning('Note template missing type in frontmatter');
        }
        return true;
    }

    protected generateNoteStructure(context: TemplateContext): string {
        const sections = this.sections
            .sort((a, b) => a.order - b.order)
            .map(section => this.generateSection(section, context))
            .join('\n\n');

        return `## üìù **Note Overview**

### **üìã Note Details**
- **Type**: ${this.noteType}
- **Date**: ${context.date.today}
- **Author**: ${context.user.name}
- **Tags**: ${this.tags.join(', ')}

### **üéØ Purpose**
${this.generateNotePurpose(context)}

---

${sections}

---

## üìä **Key Insights**

### **üí° Main Points**
- 
- 
- 

### **üîç Action Items**
- [ ] 
- [ ] 
- [ ]

### **üìö References**
- 
- 
- 

---

## üîÑ **Follow-up**

### **‚è∞ Next Steps**
- 
- 
- 

### **üìÖ Reminders**
- 
- 
- 

---

${this.generateFooter()}`;
    }

    private generateSection(section: NoteSection, context: TemplateContext): string {
        const required = section.required ? ' **(Required)**' : '';
        let content = '';

        if (section.template) {
            // Simple template variable replacement
            content = section.template
                .replace(/\{\{date\}\}/g, context.date.today)
                .replace(/\{\{author\}\}/g, context.user.name)
                .replace(/\{\{title\}\}/g, context.file.name);
        } else {
            content = `<!-- Add content for ${section.name} -->`;
        }

        return `### **${section.name}**${required}

${content}`;
    }

    protected generateNotePurpose(context: TemplateContext): string {
        // Override in subclasses for specific note types
        return 'This note serves as a comprehensive record of important information and insights.';
    }
}

// ============================================================================
// TEMPLATE REGISTRY
// ============================================================================

export class TemplateRegistry {
    private static instance: TemplateRegistry;
    private templates: Map<string, AbstractBaseTemplate> = new Map();

    static getInstance(): TemplateRegistry {
        if (!TemplateRegistry.instance) {
            TemplateRegistry.instance = new TemplateRegistry();
        }
        return TemplateRegistry.instance;
    }

    register(template: AbstractBaseTemplate): void {
        this.templates.set(template.name, template);
        logger.logInfo(`Template registered: ${template.name}`, {
            category: template.category,
            version: template.version
        });
    }

    get(name: string): AbstractBaseTemplate | undefined {
        return this.templates.get(name);
    }

    getByCategory(category: string): AbstractBaseTemplate[] {
        return Array.from(this.templates.values())
            .filter(template => template.category === category);
    }

    list(): string[] {
        return Array.from(this.templates.keys());
    }

    render(templateName: string, context: TemplateContext): TemplateResult {
        const template = this.get(templateName);
        if (!template) {
            return {
                content: '',
                metadata: {},
                success: false,
                errors: [`Template not found: ${templateName}`]
            };
        }

        if (!template.validate(context)) {
            return {
                content: '',
                metadata: {},
                success: false,
                errors: [`Template validation failed: ${templateName}`]
            };
        }

        try {
            return template.render(context);
        } catch (error) {
            logger.logError(`Template render error: ${templateName}`, { error, context });
            return {
                content: '',
                metadata: {},
                success: false,
                errors: [`Template render failed: ${templateName}`, (error as Error).message]
            };
        }
    }
}

export const templateRegistry = TemplateRegistry.getInstance();

export default AbstractBaseTemplate;
